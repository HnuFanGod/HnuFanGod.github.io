<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="简介不了，慢慢观察">
<meta property="og:type" content="website">
<meta property="og:title" content="帆帆的BLOG">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="帆帆的BLOG">
<meta property="og:description" content="简介不了，慢慢观察">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="一只小帆帆">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>帆帆的BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">帆帆的BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/22/Tetris/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="一只小帆帆">
      <meta itemprop="description" content="简介不了，慢慢观察">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帆帆的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/22/Tetris/" class="post-title-link" itemprop="url">Tetris</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-22 18:55:18" itemprop="dateCreated datePublished" datetime="2022-07-22T18:55:18+08:00">2022-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-01 11:28:40" itemprop="dateModified" datetime="2022-08-01T11:28:40+08:00">2022-08-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">C++制作小游戏</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">实战</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SFML/Graphics.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> sf;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> field[M][N] = &#123;<span class="number">0</span>&#125;;    <span class="comment">//界面所有格子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;<span class="type">int</span> x,y;&#125; a[<span class="number">4</span>], b[<span class="number">4</span>]; <span class="comment">//数组a保存每个图形块的位置，数组b用于暂存数组a的信息，防止操作失败而原有信息丢失。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> figures[<span class="number">7</span>][<span class="number">4</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, <span class="comment">// I   字母形状对应图形形状，数字代表刷新出来的图案所在的位置</span></span><br><span class="line">    <span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>, <span class="comment">// Z</span></span><br><span class="line">    <span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>, <span class="comment">// S</span></span><br><span class="line">    <span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>, <span class="comment">// T</span></span><br><span class="line">    <span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, <span class="comment">// L</span></span><br><span class="line">    <span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>, <span class="comment">// J</span></span><br><span class="line">    <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="comment">// O</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">      <span class="keyword">if</span> (a[i].x&lt;<span class="number">0</span> || a[i].x&gt;=N || a[i].y&gt;=M) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//判断是否出界</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (field[a[i].y][a[i].x]) <span class="keyword">return</span> <span class="number">0</span>;          <span class="comment">//判断是否会和已有图形重合</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));     </span><br><span class="line"></span><br><span class="line">    <span class="function">RenderWindow <span class="title">window</span><span class="params">(VideoMode(<span class="number">320</span>, <span class="number">480</span>), <span class="string">&quot;The Game!&quot;</span>)</span></span>;  </span><br><span class="line"></span><br><span class="line">    Texture t1,t2,t3;</span><br><span class="line">    t1.<span class="built_in">loadFromFile</span>(<span class="string">&quot;images/tiles.png&quot;</span>);         </span><br><span class="line">    t2.<span class="built_in">loadFromFile</span>(<span class="string">&quot;images/background.png&quot;</span>);</span><br><span class="line">    t3.<span class="built_in">loadFromFile</span>(<span class="string">&quot;images/frame.png&quot;</span>);     <span class="comment">//加载背景图片</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Sprite <span class="title">s</span><span class="params">(t1)</span>, <span class="title">background</span><span class="params">(t2)</span>, <span class="title">frame</span><span class="params">(t3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx=<span class="number">0</span>; <span class="type">bool</span> rotate=<span class="number">0</span>; <span class="type">int</span> colorNum=<span class="number">1</span>;     <span class="comment">//dx控制图形偏移量，rotate决定是否旋转</span></span><br><span class="line">    <span class="type">float</span> timer=<span class="number">0</span>,delay=<span class="number">0.3</span>;          <span class="comment">//delay为图形每次下移一格的时间间隔</span></span><br><span class="line"></span><br><span class="line">    Clock clock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window.<span class="built_in">isOpen</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> time = clock.<span class="built_in">getElapsedTime</span>().<span class="built_in">asSeconds</span>();  <span class="comment">//获取时钟开始后经过的时间并转化为秒</span></span><br><span class="line">        clock.<span class="built_in">restart</span>();  <span class="comment">//时钟重启</span></span><br><span class="line">        timer+=time;   </span><br><span class="line"></span><br><span class="line">        Event e;</span><br><span class="line">        <span class="keyword">while</span> (window.<span class="built_in">pollEvent</span>(e))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.type == Event::Closed)</span><br><span class="line">                window.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e.type == Event::KeyPressed)</span><br><span class="line">              <span class="keyword">if</span> (e.key.code==Keyboard::Up) rotate=<span class="literal">true</span>;  <span class="comment">//按下上键使图形旋转</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (e.key.code==Keyboard::Left) dx=<span class="number">-1</span>;  <span class="comment">//按下左键使图形左移</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (e.key.code==Keyboard::Right) dx=<span class="number">1</span>;  <span class="comment">//按下右键使图形右移</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Keyboard::<span class="built_in">isKeyPressed</span>(Keyboard::Down)) delay=<span class="number">0.05</span>; <span class="comment">//按下下键使图形加速下移，通过将一次图形自由下降间隔改为0.05</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// &lt;- Move -&gt; ///</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)  &#123; b[i]=a[i]; a[i].x+=dx; &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">check</span>()) <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) a[i]=b[i];  <span class="comment">//如果出界或者和原有图形重合，移位失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////Rotate//////</span></span><br><span class="line">    <span class="keyword">if</span> (rotate)</span><br><span class="line">      &#123;</span><br><span class="line">        Point p = a[<span class="number">1</span>]; <span class="comment">//将图形第二个块设置为中心旋转点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="type">int</span> x = a[i].y-p.y;  <span class="comment">//计算个小块与中间点纵向位移</span></span><br><span class="line">            <span class="type">int</span> y = a[i].x-p.x;  <span class="comment">//计算个小块与中间点横向位移</span></span><br><span class="line">            a[i].x = p.x - x;    <span class="comment">//将纵向位移转化为横向位移</span></span><br><span class="line">            a[i].y = p.y + y;    <span class="comment">//将横向位移转化为纵向位移</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="built_in">check</span>()) <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) a[i]=b[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////Tick//////</span></span><br><span class="line">    <span class="keyword">if</span> (timer&gt;delay)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123; b[i]=a[i]; a[i].y+=<span class="number">1</span>; &#125;   <span class="comment">//方块掉落</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>())</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) field[b[i].y][b[i].x]=colorNum;   <span class="comment">//将格子颜色信息储存</span></span><br><span class="line"></span><br><span class="line">         colorNum=<span class="number">1</span>+<span class="built_in">rand</span>()%<span class="number">7</span>;</span><br><span class="line">         <span class="type">int</span> n=<span class="built_in">rand</span>()%<span class="number">7</span>;   <span class="comment">//决定哪个形状</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">           &#123;</span><br><span class="line">            a[i].x = figures[n][i] % <span class="number">2</span>;</span><br><span class="line">            a[i].y = figures[n][i] / <span class="number">2</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         timer=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///////check lines//////////</span></span><br><span class="line">    <span class="type">int</span> k=M<span class="number">-1</span>;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=M<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)   <span class="comment">//从最下面的一行开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;   <span class="comment">//记录每行方块个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (field[i][j]) count++;</span><br><span class="line">            field[k][j]=field[i][j];  <span class="comment">//某行被消掉后，上面的向下掉落机制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count&lt;N) k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dx=<span class="number">0</span>; rotate=<span class="number">0</span>; delay=<span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////draw//////////</span></span><br><span class="line">    window.<span class="built_in">clear</span>(Color::White);    </span><br><span class="line">    window.<span class="built_in">draw</span>(background);</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)            <span class="comment">//画界面内已落下的方块</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (field[i][j]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">         s.<span class="built_in">setTextureRect</span>(<span class="built_in">IntRect</span>(field[i][j]*<span class="number">18</span>,<span class="number">0</span>,<span class="number">18</span>,<span class="number">18</span>));  <span class="comment">//显示部分纹理；四个参数：矩形左坐标、顶部坐标、宽度、高度</span></span><br><span class="line">         s.<span class="built_in">setPosition</span>(j*<span class="number">18</span>,i*<span class="number">18</span>);</span><br><span class="line">         s.<span class="built_in">move</span>(<span class="number">28</span>,<span class="number">31</span>); <span class="comment">//offset</span></span><br><span class="line">         window.<span class="built_in">draw</span>(s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)        <span class="comment">//画正在落下的方块</span></span><br><span class="line">      &#123;</span><br><span class="line">        s.<span class="built_in">setTextureRect</span>(<span class="built_in">IntRect</span>(colorNum*<span class="number">18</span>,<span class="number">0</span>,<span class="number">18</span>,<span class="number">18</span>));  </span><br><span class="line">        s.<span class="built_in">setPosition</span>(a[i].x*<span class="number">18</span>,a[i].y*<span class="number">18</span>);</span><br><span class="line">        s.<span class="built_in">move</span>(<span class="number">28</span>,<span class="number">31</span>); <span class="comment">//offset</span></span><br><span class="line">        window.<span class="built_in">draw</span>(s);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    window.<span class="built_in">draw</span>(frame);</span><br><span class="line">    window.<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="/download/Tetris.zip">点击下载</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Controlling-the-2D-camera-with-views/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="一只小帆帆">
      <meta itemprop="description" content="简介不了，慢慢观察">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帆帆的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Controlling-the-2D-camera-with-views/" class="post-title-link" itemprop="url">预备知识(Controlling the 2D camera with views)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-14 16:31:51 / 修改时间：17:07:02" itemprop="dateCreated datePublished" datetime="2022-07-14T16:31:51+08:00">2022-07-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">C++制作小游戏</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">准备工作</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>官方文档：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-view.php">Controlling the 2D camera with views (SFML &#x2F; Learn &#x2F; 2.5 Tutorials) (sfml-dev.org)</a></p>
<h1 id="什么是视图？"><a href="#什么是视图？" class="headerlink" title="什么是视图？"></a>什么是视图？</h1><p>在游戏中，关卡比窗口本身大得多的情况并不少见。你只看到其中的一小部分。在RPG，平台游戏和许多其他类型中通常都是这种情况。开发人员可能倾向于忘记的是，他们在<em>2D世界中</em>定义实体，而不是直接在窗口中定义实体。窗口只是一个视图，它显示了整个世界的特定区域。平行绘制同一世界的多个视图，或者将世界绘制到纹理而不是窗口是完全可以的。世界本身保持不变，变化的只是人们看待它的方式。</p>
<p>由于在窗口中看到的内容只是整个2D世界的一小部分，因此您需要一种方法来指定窗口中显示世界的哪个部分。此外，您可能还希望定义此区域在<em>窗口中的显示</em>位置&#x2F;方式。这是 SFML 视图的两个主要功能。</p>
<p>总而言之，如果要滚动、旋转或缩放世界，则需要视图。它们也是创建分屏和迷你地图的关键。</p>
<h1 id="定义视图的查看区域"><a href="#定义视图的查看区域" class="headerlink" title="定义视图的查看区域"></a>定义视图的查看区域</h1><p>在 SFML 中封装视图的类是 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1View.php"><code>sf：：View</code></a>。它可以直接使用要查看的区域的定义来构造：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 2D 世界的矩形区域创建一个视图以显示</span></span><br><span class="line"><span class="function">sf::View <span class="title">view1</span><span class="params">(sf::FloatRect(<span class="number">200.f</span>, <span class="number">200.f</span>, <span class="number">300.f</span>, <span class="number">200.f</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个具有中心和大小的视图</span></span><br><span class="line"><span class="function">sf::View <span class="title">view2</span><span class="params">(sf::Vector2f(<span class="number">350.f</span>, <span class="number">300.f</span>), sf::Vector2f(<span class="number">300.f</span>, <span class="number">200.f</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个定义是等效的：两个视图将显示 2D 世界的相同区域，即以点 （350， 300） <em>为中心的</em> 300x200 矩形。</p>
<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Controlling-the-2D-camera-with-views/graphics-view-initial.png" alt="graphics-view-initial"></p>
<p>如果不想在构造时定义视图或以后要对其进行修改，则可以使用等效的 setter：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sf::View view1;</span><br><span class="line">view1.<span class="built_in">reset</span>(sf::<span class="built_in">FloatRect</span>(<span class="number">200.f</span>, <span class="number">200.f</span>, <span class="number">300.f</span>, <span class="number">200.f</span>));</span><br><span class="line"></span><br><span class="line">sf::View view2;</span><br><span class="line">view2.<span class="built_in">setCenter</span>(sf::<span class="built_in">Vector2f</span>(<span class="number">350.f</span>, <span class="number">300.f</span>));</span><br><span class="line">view2.<span class="built_in">setSize</span>(sf::<span class="built_in">Vector2f</span>(<span class="number">200.f</span>, <span class="number">200.f</span>));</span><br></pre></td></tr></table></figure>

<p>定义视图后，您以对其进行变换，使其显示 2D 世界的平移&#x2F;旋转&#x2F;缩放版本。</p>
<h2 id="移动（滚动）视图"><a href="#移动（滚动）视图" class="headerlink" title="移动（滚动）视图"></a>移动（滚动）视图</h2><p>视图始终由其中心操控（实体由左上角操控）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动视图到点 (200, 200) 处</span></span><br><span class="line">view.<span class="built_in">setCenter</span>(<span class="number">200.f</span>, <span class="number">200.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将视图移动 (100, 100) 的偏移量（因此它的最终位置是 (300, 300)）</span></span><br><span class="line">view.<span class="built_in">move</span>(<span class="number">100.f</span>, <span class="number">100.f</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Controlling-the-2D-camera-with-views/graphics-view-translated.png" alt="graphics-view-translated"></p>
<h2 id="旋转视图"><a href="#旋转视图" class="headerlink" title="旋转视图"></a>旋转视图</h2><p>使用<code>setRotation</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将视图旋转 20 度</span></span><br><span class="line">view.<span class="built_in">setRotation</span>(<span class="number">20.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于当前方向将视图旋转 5 度（因此其最终方向为 25 度）</span></span><br><span class="line">view.<span class="built_in">rotate</span>(<span class="number">5.f</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Controlling-the-2D-camera-with-views/graphics-view-rotated.png" alt="graphics-view-rotated"></p>
<h2 id="缩放视图"><a href="#缩放视图" class="headerlink" title="缩放视图"></a>缩放视图</h2><p>使用<code>setSize</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整视图大小以显示 1200x800 区域（我们看到更大的区域，所以这是缩小）</span></span><br><span class="line">view.<span class="built_in">setSize</span>(<span class="number">1200.f</span>, <span class="number">800.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于当前大小缩放视图（应用因子 0.5，因此其最终大小为 600x400）</span></span><br><span class="line">view.<span class="built_in">zoom</span>(<span class="number">0.5f</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Controlling-the-2D-camera-with-views/graphics-view-scaled.png" alt="graphics-view-scaled"></p>
<h1 id="定义视图的查看方式"><a href="#定义视图的查看方式" class="headerlink" title="定义视图的查看方式"></a>定义视图的查看方式</h1><p>现在，您已经定义了在窗口中可以看到 2D 世界的哪个部分，让我们定义它的显示<em>位置</em>。默认情况下，查看的内容占据整个窗口。如果视图的大小与窗口相同，则所有内容都以 1：1 呈现。如果视图小于或大于窗口，则所有内容都将缩放以适合窗口。</p>
<p>此默认行为适用于大多数情况，但有时可能需要更改。例如，要在多人游戏中拆分屏幕，您可能希望使用两个视图，每个视图仅占据窗口的一半。您还可以通过将整个世界绘制到在窗口角落的一小块区域中渲染的视图来实现小地图。显示视图内容的区域称为<em>视区</em>。</p>
<p>要设置视图的视口，可以使用setViewport函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个居中的视口，窗口大小的一半</span></span><br><span class="line">view.<span class="built_in">setViewport</span>(sf::<span class="built_in">FloatRect</span>(<span class="number">0.25f</span>, <span class="number">0.25</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Controlling-the-2D-camera-with-views/graphics-view-viewport.png" alt="graphics-view-viewport"></p>
<p>视口不是以像素为单位定义的，而是以窗口大小的比率来定义的。</p>
<p>使用视口，可以直接拆分多人游戏的屏幕：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 玩家1（屏幕左侧）</span></span><br><span class="line">player1View.<span class="built_in">setViewport</span>(sf::<span class="built_in">FloatRect</span>(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">0.5f</span>, <span class="number">1.f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家2（屏幕右侧）</span></span><br><span class="line">player2View.<span class="built_in">setViewport</span>(sf::<span class="built_in">FloatRect</span>(<span class="number">0.5f</span>, <span class="number">0.f</span>, <span class="number">0.5f</span>, <span class="number">1.f</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Controlling-the-2D-camera-with-views/graphics-view-split-screen.png" alt="graphics-view-split-screen"></p>
<p>迷你地图：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 游戏视图（全窗口）</span></span><br><span class="line">gameView.<span class="built_in">setViewport</span>(sf::<span class="built_in">FloatRect</span>(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小地图（右上角）</span></span><br><span class="line">minimapView.<span class="built_in">setViewport</span>(sf::<span class="built_in">FloatRect</span>(<span class="number">0.75f</span>, <span class="number">0.f</span>, <span class="number">0.25f</span>, <span class="number">0.25f</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Controlling-the-2D-camera-with-views/graphics-view-minimap.png" alt="graphics-view-minimap"></p>
<h1 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h1><p>要使用视图绘制某些内容，必须在调用要绘制的目标（<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderWindow.php"><code>sf::RenderWindow</code></a>或<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTexture.php"><code>sf::RenderTexture）</code></a>的函数<code>setView</code>后绘制它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个视图</span></span><br><span class="line"><span class="function">sf::View <span class="title">view</span><span class="params">(sf::FloatRect(<span class="number">0.f</span>, <span class="number">0.f</span>, <span class="number">1000.f</span>, <span class="number">600.f</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活它</span></span><br><span class="line">window.<span class="built_in">setView</span>(view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在那个视图上画一些东西</span></span><br><span class="line">window.<span class="built_in">draw</span>(some_sprite);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要进行可见性检查？ 检索视图</span></span><br><span class="line">sf::View currentView = window.<span class="built_in">getView</span>();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>视图将保持活动状态，直到您设置另一个视图。这意味着总有一个视图来定义目标中显示的内容以及绘制位置。如果未显式设置任何视图，则呈现器目标将使用其自己的默认视图，该视图与其大小 1：1 匹配。你可以使用该函数获取呈现器目标的默认视图。如果要基于它定义自己的视图，或者还原它以在场景顶部绘制固定实体（如 GUI），这将非常有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个默认视图一半大小的视图</span></span><br><span class="line">sf::View view = window.<span class="built_in">getDefaultView</span>();</span><br><span class="line">view.<span class="built_in">zoom</span>(<span class="number">0.5f</span>);</span><br><span class="line">window.<span class="built_in">setView</span>(view);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复默认视图</span></span><br><span class="line">window.<span class="built_in">setView</span>(window.<span class="built_in">getDefaultView</span>());</span><br></pre></td></tr></table></figure>

<p>每当您更新视图时，都需要再次调用<code>setView</code>以应用修改。</p>
<h1 id="调整窗口大小时显示更多内容"><a href="#调整窗口大小时显示更多内容" class="headerlink" title="调整窗口大小时显示更多内容"></a>调整窗口大小时显示更多内容</h1><p>由于默认视图在创建窗口后永远不会更改，因此查看的内容始终相同。因此，当调整窗口大小时，所有内容都会被挤压&#x2F;拉伸到新大小。</p>
<p>如果不想显示此默认行为，而是要根据窗口的新大小显示更多&#x2F;更少的内容，则只需使用窗口大小更新视图的大小即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line">sf::Event event;</span><br><span class="line"><span class="keyword">while</span> (window.<span class="built_in">pollEvent</span>(event))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕捉调整大小事件</span></span><br><span class="line">    <span class="keyword">if</span> (event.type == sf::Event::Resized)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将视图更新为窗口的新大小</span></span><br><span class="line">        <span class="function">sf::FloatRect <span class="title">visibleArea</span><span class="params">(<span class="number">0.f</span>, <span class="number">0.f</span>, event.size.width, event.size.height)</span></span>;</span><br><span class="line">        window.<span class="built_in">setView</span>(sf::<span class="built_in">View</span>(visibleArea));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h1><p>使用自定义视图时，或者在不使用上述代码的情况下调整窗口大小时，目标上显示的像素不再与 2D 世界中的单位匹配。例如，点击像素（10，50）可能会到达你世界的点（26.5，-84）。您最终必须使用转换函数<code>mapPixelToCoords</code>将像素坐标映射到世界坐标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前鼠标在窗口中的位置</span></span><br><span class="line">sf::Vector2i pixelPos = sf::Mouse::<span class="built_in">getPosition</span>(window);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其转换为世界坐标</span></span><br><span class="line">sf::Vector2f worldPos = window.<span class="built_in">mapPixelToCoords</span>(pixelPos);</span><br></pre></td></tr></table></figure>

<p>默认情况下，使用当前视图。如果要使用非活动视图转换坐标，可以将其作为附加参数传递给函数<code>mapPixelToCoords</code></p>
<p>相反，使用<code>mapCoordsToPixel</code>函数也可以将世界坐标转换为像素坐标。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Position-rotation-scale-Transforming-entities/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="一只小帆帆">
      <meta itemprop="description" content="简介不了，慢慢观察">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帆帆的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Position-rotation-scale-Transforming-entities/" class="post-title-link" itemprop="url">预备知识(Position, rotation, scale: Transforming entities)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-14 15:55:09 / 修改时间：16:24:03" itemprop="dateCreated datePublished" datetime="2022-07-14T15:55:09+08:00">2022-07-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">C++制作小游戏</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">准备工作</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>官方文档：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-transform.php">Position, rotation, scale: Transforming entities (SFML &#x2F; Learn &#x2F; 2.5 Tutorials) (sfml-dev.org)</a></p>
<h1 id="转换SFML实体"><a href="#转换SFML实体" class="headerlink" title="转换SFML实体"></a>转换SFML实体</h1><p>所有 SFML 类（子画面、文本、形状）都使用相同的转换接口：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Transformable.php"><code>sf::Transformable</code></a>。此基类提供了一个简单的 API 来移动、旋转和缩放实体。它没有提供最大的灵活性，而是定义了一个易于理解和使用的界面，它涵盖了所有用例的99% - 对于剩余的1%，请参阅最后一章。</p>
<p><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Transformable.php"><code>sf::Transformable</code></a>（及其所有派生类）定义了四个属性：<strong>位置</strong>、<strong>旋转</strong>、<strong>缩放</strong>和<strong>原点</strong>。他们都有各自的获取者和二传手。这些转换组件都是相互独立的：如果要更改实体的方向，则只需设置其旋转属性，而不必关心当前位置和缩放。</p>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “实体”可以是 sf::Sprite、sf::Text、sf::Shape 或任何其他可转换的类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置实体的绝对位置</span></span><br><span class="line">entity.<span class="built_in">setPosition</span>(<span class="number">10.f</span>, <span class="number">50.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将实体相对于其当前位置移动</span></span><br><span class="line">entity.<span class="built_in">move</span>(<span class="number">5.f</span>, <span class="number">5.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索实体的绝对位置</span></span><br><span class="line">sf::Vector2f position = entity.<span class="built_in">getPosition</span>(); <span class="comment">// = (15, 55)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Position-rotation-scale-Transforming-entities/graphics-transform-position.png" alt="graphics-transform-position"></p>
<p>默认情况下，实体相对于其左上角的位置。</p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>以度为单位，按顺时针顺序定义（因为 Y 轴在 SFML 中指向下方）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “实体”可以是 sf::Sprite、sf::Text、sf::Shape 或任何其他可转换的类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置实体的绝对旋转</span></span><br><span class="line">entity.<span class="built_in">setRotation</span>(<span class="number">45.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于其当前方向旋转实体</span></span><br><span class="line">entity.<span class="built_in">rotate</span>(<span class="number">10.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索实体的绝对旋转</span></span><br><span class="line"><span class="type">float</span> rotation = entity.<span class="built_in">getRotation</span>(); <span class="comment">// = 55</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Position-rotation-scale-Transforming-entities/graphics-transform-rotation.png" alt="graphics-transform-rotation"></p>
<p>调用getRotation时，SFML 始终返回范围 [0， 360） 中的角度</p>
<p>与位置一样，默认情况下，旋转是围绕左上角执行的，但这可以通过设置原点来更改。</p>
<h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><p>比例因子允许调整实体的大小。默认比例为 1。将其设置为小于 1 的值会使实体变小，大于 1 会使实体变大。还允许使用负比例值，以便可以镜像实体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “实体”可以是 sf::Sprite、sf::Text、sf::Shape 或任何其他可转换的类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置实体的绝对比例</span></span><br><span class="line">entity.<span class="built_in">setScale</span>(<span class="number">4.f</span>, <span class="number">1.6f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于其当前规模缩放实体</span></span><br><span class="line">entity.<span class="built_in">scale</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索实体的绝对比例</span></span><br><span class="line">sf::Vector2f scale = entity.<span class="built_in">getScale</span>(); <span class="comment">// = (2, 0.8)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Position-rotation-scale-Transforming-entities/graphics-transform-scale.png" alt="graphics-transform-scale"></p>
<h2 id="原点"><a href="#原点" class="headerlink" title="原点"></a>原点</h2><p>原点是其他三个变换的中心点。图元的位置是其原点的位置，其旋转围绕原点执行，并且缩放也相对于原点应用。默认情况下，它是实体的左上角（点 （0， 0））。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “实体”可以是 sf::Sprite、sf::Text、sf::Shape 或任何其他可转换的类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置实体的原点</span></span><br><span class="line">entity.<span class="built_in">setOrigin</span>(<span class="number">10.f</span>, <span class="number">20.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索实体的位置</span></span><br><span class="line">sf::Vector2f origin = entity.<span class="built_in">getOrigin</span>(); <span class="comment">// = (10, 20)</span></span><br></pre></td></tr></table></figure>

<h1 id="定界框"><a href="#定界框" class="headerlink" title="定界框"></a>定界框</h1><p>转换实体并绘制它们之后，您可能希望使用它们执行一些计算，例如检查碰撞。</p>
<p>SFML 实体可以为您提供其边界框。边界框是包含属于图元的所有点的最小矩形，其边与 X 轴和 Y 轴对齐。</p>
<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Position-rotation-scale-Transforming-entities/graphics-transform-bounds.png" alt="graphics-transform-bounds"></p>
<p>在实现碰撞检测时，边界框非常有用：可以非常快速地对点或另一个轴对齐矩形进行检查，并且其面积足够接近真实实体的面积以提供良好的近似值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检索实体的原点</span></span><br><span class="line">sf::FloatRect boundingBox = entity.<span class="built_in">getGlobalBounds</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查与点的碰撞</span></span><br><span class="line">sf::Vector2f point = ...;</span><br><span class="line"><span class="keyword">if</span> (boundingBox.<span class="built_in">contains</span>(point))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 碰撞！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查与另一个框的碰撞（如另一个实体的边界框）</span></span><br><span class="line">sf::FloatRect otherBox = ...;</span><br><span class="line"><span class="keyword">if</span> (boundingBox.<span class="built_in">intersects</span>(otherBox))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 碰撞！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getGlobalBounds</code>函数之所以这么命名，是因为它返回全局坐标系中实体的边界框，即在应用其所有变换（位置、旋转、缩放）之后</p>
<p>还有另一个函数<code>getLocalBounds</code>返回实体在其<em>局部</em>坐标系中的边界框（在应用其变换之前）。例如，此函数可用于获取实体的初始大小，或执行更具体的计算。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="一只小帆帆">
      <meta itemprop="description" content="简介不了，慢慢观察">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帆帆的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/" class="post-title-link" itemprop="url">预备知识(Shape)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-14 15:13:42 / 修改时间：15:56:11" itemprop="dateCreated datePublished" datetime="2022-07-14T15:13:42+08:00">2022-07-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">C++制作小游戏</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">准备工作</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>官方文档：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-shape.php">Shapes (SFML &#x2F; Learn &#x2F; 2.5 Tutorials) (sfml-dev.org)</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>SFML 提供了一组表示简单形状实体的类。每种类型的形状都是一个单独的类，但它们都派生自同一个基类，以便它们可以访问相同的公共特征子集。然后，每个类都添加自己的属性：圆类的半径属性、矩形类的大小、多边形类的点等。</p>
<h1 id="常见形状属性"><a href="#常见形状属性" class="headerlink" title="常见形状属性"></a>常见形状属性</h1><h2 id="变换（位置、旋转、比例）"><a href="#变换（位置、旋转、比例）" class="headerlink" title="变换（位置、旋转、比例）"></a>变换（位置、旋转、比例）</h2><p>这些属性是所有 SFML 图形类通用的，因此在单独的教程 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-transform.php">Transforming entities</a>介绍了这些属性：</p>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>形状的基本属性之一是其颜色。您可以使用<code>setFillColor</code>函数进行更改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sf::CircleShape <span class="title">shape</span><span class="params">(<span class="number">50.f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将形状颜色设置为绿色</span></span><br><span class="line">shape.<span class="built_in">setFillColor</span>(sf::<span class="built_in">Color</span>(<span class="number">100</span>, <span class="number">250</span>, <span class="number">50</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-circle.png" alt="graphics-shape-circle"></p>
<h2 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h2><p>形状可以有轮廓。可以使用<code>SetOutlineHickness</code>和<code>setOutlineColor</code>函数设置轮廓的厚度和颜色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sf::CircleShape <span class="title">shape</span><span class="params">(<span class="number">50.f</span>)</span></span>;</span><br><span class="line">shape.<span class="built_in">setFillColor</span>(sf::<span class="built_in">Color</span>(<span class="number">150</span>, <span class="number">50</span>, <span class="number">250</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个 10 像素宽的橙色轮廓</span></span><br><span class="line">shape.<span class="built_in">setOutlineThickness</span>(<span class="number">10.f</span>);</span><br><span class="line">shape.<span class="built_in">setOutlineColor</span>(sf::<span class="built_in">Color</span>(<span class="number">250</span>, <span class="number">150</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-outline.png" alt="graphics-shape-outline"></p>
<p>默认情况下，轮廓从形状向外挤出（例如，如果有一个半径为10、轮廓厚度为5的圆，则圆的总半径为15）。通过设置负厚度，可以使其向形状中心挤出。<br>要禁用轮廓，请将其厚度设置为0。如果只需要轮廓，可以将填充颜色设置为<code>sf：：color：：Transparent</code>。</p>
<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p><code>shapes</code>也可以有<code>texture</code>，就像 <code>sprites</code>一样。要指定要映射到形状的纹理的一部分，必须使用<code>setTextureRect</code>函数。它需要纹理矩形映射到形状的边界矩形。这种方法没有提供最大的灵活性，但比单独设置形状每个点的纹理坐标更容易使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sf::CircleShape <span class="title">shape</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 100x100 带纹理的矩形映射到形状</span></span><br><span class="line">shape.<span class="built_in">setTexture</span>(&amp;texture); <span class="comment">// texture是一个 sf::Texture</span></span><br><span class="line">shape.<span class="built_in">setTextureRect</span>(sf::<span class="built_in">IntRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>请注意，轮廓没有纹理。</p>
<p>重要的是要知道纹理是用形状的填充颜色调制（乘以）的。如果其填充颜色为<code>sf：：color：：white</code>，则纹理将显示为未修改。</p>
<p>要禁用纹理，请调用<code>setTexture（NULL）</code>。</p>
<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-texture.png" alt="graphics-shape-texture"></p>
<h1 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h1><p>绘制形状就像绘制任何其他 SFML 实体一样简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.<span class="built_in">draw</span>(shape);</span><br></pre></td></tr></table></figure>

<h1 id="内置形状类型"><a href="#内置形状类型" class="headerlink" title="内置形状类型"></a>内置形状类型</h1><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><p>若要绘制矩形，可以使用 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RectangleShape.php"><code>sf::RectangleShape</code></a> 类。它只有一个属性：矩形的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a 120x50 rectangle</span></span><br><span class="line"><span class="function">sf::RectangleShape <span class="title">rectangle</span><span class="params">(sf::Vector2f(<span class="number">120.f</span>, <span class="number">50.f</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// change the size to 100x100</span></span><br><span class="line">rectangle.<span class="built_in">setSize</span>(sf::<span class="built_in">Vector2f</span>(<span class="number">100.f</span>, <span class="number">100.f</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-rectangle.png" alt="graphics-shape-rectangle"></p>
<h2 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h2><p>圆圈由 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1CircleShape.php"><code>sf::CircleShape</code></a> 类表示。它有两个属性：半径和边数。边数是一个可选属性，它允许您调整圆的“质量”：圆必须由具有多条边的多边形近似（图形卡无法直接绘制完美的圆），并且此属性定义了圆近似将具有多少条边。如果你画小圆圈，你可能只需要几个边。如果您绘制大圆圈或缩放常规圆圈，则很可能需要更多的边。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个半径 = 200 的圆</span></span><br><span class="line"><span class="function">sf::CircleShape <span class="title">circle</span><span class="params">(<span class="number">200.f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将半径更改为 40</span></span><br><span class="line">circle.<span class="built_in">setRadius</span>(<span class="number">40.f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将边数（点）更改为 100</span></span><br><span class="line">circle.<span class="built_in">setPointCount</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-circle.png" alt="graphics-shape-circle"></p>
<h2 id="正多边形"><a href="#正多边形" class="headerlink" title="正多边形"></a>正多边形</h2><p>规多边形没有专用类，实际上您可以使用 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1CircleShape.php"><code>sf:;CircleShape</code></a> 类来表示任意数量的边的常规多边形：由于圆由具有多条边的多边形近似，因此您只需要使用边数即可获得所需的多边形。<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1CircleShape.php"><code>sf::CircleShape</code></a>有3个点是一个三角形，有4个点是一个正方形，依此类推。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个三角形</span></span><br><span class="line"><span class="function">sf::CircleShape <span class="title">triangle</span><span class="params">(<span class="number">80.f</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个正方形</span></span><br><span class="line"><span class="function">sf::CircleShape <span class="title">square</span><span class="params">(<span class="number">80.f</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个八边形</span></span><br><span class="line"><span class="function">sf::CircleShape <span class="title">octagon</span><span class="params">(<span class="number">80.f</span>, <span class="number">8</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-regular.png" alt="graphics-shape-regular"></p>
<h2 id="凸形"><a href="#凸形" class="headerlink" title="凸形"></a>凸形</h2><p><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1ConvexShape.php"><code>sf::ConvexShape</code></a> 类是终极形状类：它允许您定义任何<em>凸</em>形状。SFML 无法绘制凹面形状。如果需要绘制凹面形状，则必须将其拆分为多个凸面。</p>
<p>若要构造凸形状，必须首先设置它应具有的点数，然后定义点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的形状</span></span><br><span class="line">sf::ConvexShape convex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其调整为 5 点</span></span><br><span class="line">convex.<span class="built_in">setPointCount</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义点</span></span><br><span class="line">convex.<span class="built_in">setPoint</span>(<span class="number">0</span>, sf::<span class="built_in">Vector2f</span>(<span class="number">0.f</span>, <span class="number">0.f</span>));</span><br><span class="line">convex.<span class="built_in">setPoint</span>(<span class="number">1</span>, sf::<span class="built_in">Vector2f</span>(<span class="number">150.f</span>, <span class="number">10.f</span>));</span><br><span class="line">convex.<span class="built_in">setPoint</span>(<span class="number">2</span>, sf::<span class="built_in">Vector2f</span>(<span class="number">120.f</span>, <span class="number">90.f</span>));</span><br><span class="line">convex.<span class="built_in">setPoint</span>(<span class="number">3</span>, sf::<span class="built_in">Vector2f</span>(<span class="number">30.f</span>, <span class="number">100.f</span>));</span><br><span class="line">convex.<span class="built_in">setPoint</span>(<span class="number">4</span>, sf::<span class="built_in">Vector2f</span>(<span class="number">0.f</span>, <span class="number">50.f</span>));</span><br></pre></td></tr></table></figure>

<p><strong>定义点的顺序非常重要。它们必须<em>按</em>顺时针或逆时针顺序定义。如果以不一致的顺序定义它们，则形状的构造将不正确</strong></p>
<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-convex.png" alt="graphics-shape-convex"></p>
<p>尽管 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1ConvexShape.php"><code>sf::ConvexShape</code></a> 的名称暗示它应该仅用于表示凸形状，但它的要求稍微宽松一些。实际上，您的形状必须满足的唯一要求是，如果您继续绘制从其<em>重心</em>到其所有点的线条，则必须以相同的顺序绘制这些线条。您不得“跳到前一行后面”。在内部，凸形形状是使用<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Triangle_fan">三角形风扇</a>自动构造的，因此，如果您的形状可由三角形风扇表示，则可以使用 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1ConvexShape.php"><code>sf::ConvexShape</code></a>。有了这个宽松的定义，例如，您可以使用<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1ConvexShape.php"><code>sf::ConvexShape</code></a>绘制星星。</p>
<h2 id="线"><a href="#线" class="headerlink" title="线"></a>线</h2><p>线条没有形状类。原因很简单：如果你的线有一个粗细，它是一个矩形。如果没有，可以用直线基元绘制。</p>
<p>带粗细的线条：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sf::RectangleShape <span class="title">line</span><span class="params">(sf::Vector2f(<span class="number">150.f</span>, <span class="number">5.f</span>))</span></span>;</span><br><span class="line">line.<span class="built_in">rotate</span>(<span class="number">45.f</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-line-rectangle.png" alt="graphics-shape-line-rectangle"></p>
<p>不带粗细的线条：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sf::Vertex line[] =</span><br><span class="line">&#123;</span><br><span class="line">    sf::<span class="built_in">Vertex</span>(sf::<span class="built_in">Vector2f</span>(<span class="number">10.f</span>, <span class="number">10.f</span>)),</span><br><span class="line">    sf::<span class="built_in">Vertex</span>(sf::<span class="built_in">Vector2f</span>(<span class="number">150.f</span>, <span class="number">150.f</span>))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">window.<span class="built_in">draw</span>(line, <span class="number">2</span>, sf::Lines);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-line-primitive.png" alt="graphics-shape-line-primitive"></p>
<p>要了解有关顶点和基元的详细信息，可以阅读有关<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php">顶点数组的</a>教程。</p>
<h2 id="自定义形状类型"><a href="#自定义形状类型" class="headerlink" title="自定义形状类型"></a>自定义形状类型</h2><p>可以使用自己的形状类型扩展形状类集。为此，您必须从 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Shape.php"><code>sf::Shape</code></a> 派生并覆盖两个函数：</p>
<ul>
<li><code>getPointCount</code>：返回形状中的点数</li>
<li><code>getPoint</code>：返回形状的点</li>
</ul>
<p>每当形状中的任何点发生更改时，还必须调用受保护的函数，以便基类得到通知并可以更新其内部几何。<code>update()</code></p>
<p>下面是自定义形状类的完整示例：椭圆形状。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EllipseShape</span> : <span class="keyword">public</span> sf::Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EllipseShape</span><span class="params">(<span class="type">const</span> sf::Vector2f&amp; radius = sf::Vector2f(<span class="number">0.f</span>, <span class="number">0.f</span>))</span> :</span></span><br><span class="line"><span class="function">    m_radius(radius)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRadius</span><span class="params">(<span class="type">const</span> sf::Vector2f&amp; radius)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_radius = radius;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> sf::Vector2f&amp; <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">getPointCount</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sf::Vector2f <span class="title">getPoint</span><span class="params">(std::<span class="type">size_t</span> index)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.141592654f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> angle = index * <span class="number">2</span> * pi / <span class="built_in">getPointCount</span>() - pi / <span class="number">2</span>;</span><br><span class="line">        <span class="type">float</span> x = std::<span class="built_in">cos</span>(angle) * m_radius.x;</span><br><span class="line">        <span class="type">float</span> y = std::<span class="built_in">sin</span>(angle) * m_radius.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sf::<span class="built_in">Vector2f</span>(m_radius.x + x, m_radius.y + y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"></span><br><span class="line">    sf::Vector2f m_radius;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-ellipse.png" alt="graphics-shape-ellipse"></p>
<h2 id="抗锯齿形状"><a href="#抗锯齿形状" class="headerlink" title="抗锯齿形状"></a>抗锯齿形状</h2><p>没有消除单个形状锯齿的选项。要获得消除锯齿的形状（即具有平滑边缘的形状），您必须在创建窗口时使用 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/structsf_1_1ContextSettings.php"><code>sf：：ContextSettings</code></a> 结构的相应属性全局启用消除锯齿。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sf::ContextSettings settings;</span><br><span class="line">settings.antialiasingLevel = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">sf::RenderWindow <span class="title">window</span><span class="params">(sf::VideoMode(<span class="number">800</span>, <span class="number">600</span>), <span class="string">&quot;SFML shapes&quot;</span>, sf::Style::Default, settings)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Shape/graphics-shape-antialiasing.png" alt="graphics-shape-antialiasing"></p>
<p>请记住，抗锯齿可用性取决于图形卡：它可能不支持它，或者在驱动程序设置中强制禁用它。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Text-and-fonts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="一只小帆帆">
      <meta itemprop="description" content="简介不了，慢慢观察">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帆帆的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/14/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Text-and-fonts/" class="post-title-link" itemprop="url">预备知识(Text and fonts)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-14 08:50:42 / 修改时间：15:13:50" itemprop="dateCreated datePublished" datetime="2022-07-14T08:50:42+08:00">2022-07-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">C++制作小游戏</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">准备工作</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>官方文档：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-text.php">Text and fonts (SFML &#x2F; Learn &#x2F; 2.5 Tutorials) (sfml-dev.org)</a></p>
<h1 id="加载字体"><a href="#加载字体" class="headerlink" title="加载字体"></a>加载字体</h1><p>在绘制任何文本之前，您需要有一个可用的字体，就像任何其他打印文本的程序一样。字体封装在 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Font.php"><code>sf：：Font</code></a> 类中，该类提供三个主要功能：加载字体、从中获取字形（即可视字符）以及读取其属性。</p>
<p>加载字体的最常见方法是从磁盘上的文件加载，这是通过loadFromFile函数完成的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sf::Font font;</span><br><span class="line"><span class="keyword">if</span> (!font.<span class="built_in">loadFromFile</span>(<span class="string">&quot;arial.ttf&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// error...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要加载字体，则需要将字体文件包含在应用程序中，就像所有其他资源（图像，声音等）一样。</p>
<p>还可以从内存 loadFromMemory() 或<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/system-stream.php">自定义输入流</a> loadFromStream() 加载字体文件。</p>
<p>SFML 支持最常见的字体格式。完整列表可在 API 文档中找到。</p>
<h1 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h1><p>使用 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Text.php"><code>sf::Text</code></a> 类绘制文本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sf::Text text;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择字体</span></span><br><span class="line">text.<span class="built_in">setFont</span>(font); <span class="comment">// 字体是 sf::Font</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置要显示的字符串</span></span><br><span class="line">text.<span class="built_in">setString</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置字符大小</span></span><br><span class="line">text.<span class="built_in">setCharacterSize</span>(<span class="number">24</span>); <span class="comment">// 以像素为单位，而不是点！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置颜色</span></span><br><span class="line">text.<span class="built_in">setFillColor</span>(sf::Color::Red);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文本样式</span></span><br><span class="line">text.<span class="built_in">setStyle</span>(sf::Text::Bold | sf::Text::Underlined);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主循环内，在 window.clear() 和 window.display() 之间</span></span><br><span class="line">window.<span class="built_in">draw</span>(text);</span><br></pre></td></tr></table></figure>

<p>文本也可以转换：它们具有位置，方向和比例。所涉及的函数与 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Sprite.php"><code>sf::Sprite</code></a> 类和其他 SFML 实体的函数相同。<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-transform.php">转换实体</a>教程中介绍了这些方法。</p>
<h1 id="如何避免非ASCII字符的问题"><a href="#如何避免非ASCII字符的问题" class="headerlink" title="如何避免非ASCII字符的问题"></a>如何避免非ASCII字符的问题</h1><p>正确处理非 ASCII 字符（如重音欧洲、阿拉伯或中文字符）可能很棘手。它需要很好地理解解释和绘制文本过程中涉及的各种编码。为了避免为这些编码而烦恼，有一个简单的解决方案：使用<em>宽文本字符串</em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.<span class="built_in">setString</span>(<span class="string">L&quot;יטאח&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>正是字符串前面的这个简单的“L”前缀通过告诉编译器生成一个宽字符串来使其工作。宽字符串在C++中是一个奇怪的野兽：标准没有说明它们的大小（16位？32位？），也没有说明它们使用的编码（UTF-16？UTF-32），但在大多数平台上它们会产生Unicode字符串，SFML知道如何正确处理它们。</p>
<p>请注意，C++11 标准支持新的字符类型和前缀来构建 UTF-8、UTF-16 和 UTF-32 字符串文本，但 SFML 尚不支持它们。</p>
<p>这似乎很明显，但你还必须确保使用的字体包含要绘制的字符。实际上，字体不包含所有可能字符的字形（Unicode标准中有超过100000个！），例如，阿拉伯字体将无法显示日语文本。</p>
<h1 id="创建自己的文本类"><a href="#创建自己的文本类" class="headerlink" title="创建自己的文本类"></a>创建自己的文本类</h1><p>如果 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Text.php"><code>sf::Text</code></a> 太有限，或者你想对预呈现的字形执行其他操作，<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Font.php"><code>sf::Font</code></a> 会提供你需要的一切。</p>
<p>可以检索包含特定大小的所有预渲染字形的纹理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> sf::Texture&amp; texture = font.<span class="built_in">getTexture</span>(characterSize);</span><br></pre></td></tr></table></figure>

<p>请务必注意，当请求字形时，会将其添加到纹理中。有太多的字符（请记住，超过100000个），以至于在加载字体时无法全部生成它们。相反，当您调用getGlyph函数时，它们会动态呈现（见下文）。</p>
<p>要对字体纹理执行有意义的操作，必须获取其中包含的字形的纹理坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sf::Glyph glyph = font.<span class="built_in">getGlyph</span>(character, characterSize, bold);</span><br></pre></td></tr></table></figure>

<p><code>character</code>是要获取其字形的字符的 UTF-32 代码。还必须指定字符大小，以及是需要粗体版本还是常规版本的字形。</p>
<p><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Glyph.php"><code>sf::Glyph</code></a>结构包含三个成员：</p>
<ul>
<li><code>textureRect</code>包含纹理中字形的纹理坐标</li>
<li><code>bounds</code>包含字形的边框，这有助于相对于文本的基线定位</li>
<li><code>advance</code>是要应用于获取文本中下一个字形的起始位置的水平偏移量</li>
</ul>
<p>你还可以获取字体的其他一些指标，例如两个字符之间的字距微调或行距（始终针对特定字符大小）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lineSpacing = font.<span class="built_in">getLineSpacing</span>(characterSize);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> kerning = font.<span class="built_in">getKerning</span>(character1, character2, characterSize);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/12/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Sprites-and-textures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="一只小帆帆">
      <meta itemprop="description" content="简介不了，慢慢观察">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帆帆的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/12/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Sprites-and-textures/" class="post-title-link" itemprop="url">预备知识(Sprites and textures)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-12 16:06:13" itemprop="dateCreated datePublished" datetime="2022-07-12T16:06:13+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-14 08:52:04" itemprop="dateModified" datetime="2022-07-14T08:52:04+08:00">2022-07-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">C++制作小游戏</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">准备工作</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>官方文档：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-sprite.php">Sprites and textures (SFML &#x2F; Learn &#x2F; 2.5 Tutorials) (sfml-dev.org)</a></p>
<h1 id="它们是什么？"><a href="#它们是什么？" class="headerlink" title="它们是什么？"></a>它们是什么？</h1><p>texture是一个图像。但我们称之为“ texture”，因为它有一个非常特殊的角色：映射到2D实体。</p>
<p>sprite只不过是一个纹理矩形。</p>
<p><img src="/2022/07/12/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Sprites-and-textures/graphics-sprites-definition.png" alt="graphics-sprites-definition"></p>
<p>这就是<code>Sprite and texture</code>。</p>
<h1 id="加载纹理"><a href="#加载纹理" class="headerlink" title="加载纹理"></a>加载纹理</h1><p>在创建任何精灵之前，我们需要一个有效的纹理。令人惊讶的是，在 SFML 中封装纹理的类是 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Texture.php"><code>sf::Texture</code></a>。由于纹理的唯一作用是加载并映射到图形实体，因此几乎所有的功能都是关于加载和更新纹理的。</p>
<p>加载纹理的最常见方法是从磁盘上的图像文件加载，这是通过<code>loadFromFile</code>函数完成的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sf::Texture texture;</span><br><span class="line"><span class="keyword">if</span> (!texture.<span class="built_in">loadFromFile</span>(<span class="string">&quot;image.png&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// error...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数有时可能会在没有明显原因的情况下失败。首先，检查 SFML 打印到标准输出的错误消息（检查控制台）。如果邮件无法打开文件，请确保<em>工作目录</em>（即任何文件路径将相对于其解释的目录）是您认为的目录：从桌面环境运行应用程序时，工作目录是可执行文件夹。但是，当您从 IDE（Visual Studio、Code：：Blocks 等）启动程序时，工作目录有时可能会设置为<em>项目</em>目录。这通常可以在项目设置中轻松更改。</p>
</blockquote>
<p>还可以从内存 （loadFromMemory）、<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/system-stream.php">自定义输入流</a> （loadFromStream） 或已加载的图像 （loadFromImage） 加载图像文件。后者从 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Image.php"><code>sf::Image</code></a> 加载纹理，它是一个实用程序类，可帮助存储和操作图像数据（修改像素、创建透明度通道等）。<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Image.php"><code>sf::Image</code></a>的像素保留在系统内存中，这确保了对它们的操作将尽可能快，这与驻留在视频内存中的纹理像素相反，因此检索或更新速度很慢，但绘制速度非常快。</p>
<p>SFML 支持最常见的图像文件格式。完整列表可在 API 文档中找到。</p>
<p>所有这些加载函数都有一个可选参数，如果要加载图像的较小部分，可以使用该参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载一个从 (10, 10) 开始的 32x32 矩形</span></span><br><span class="line"><span class="keyword">if</span> (!texture.<span class="built_in">loadFromFile</span>(<span class="string">&quot;image.png&quot;</span>, sf::<span class="built_in">IntRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">32</span>, <span class="number">32</span>)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// error...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Rect.php"><code>sf::IntRect</code></a> 类是表示矩形的简单实用工具类型。其构造函数采用左上角的坐标和矩形的大小。</p>
<p>如果你不想从图像加载纹理，而是希望直接从像素数组更新纹理，则可以将其创建为空，稍后再更新：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的 200x200 纹理</span></span><br><span class="line"><span class="keyword">if</span> (!texture.<span class="built_in">create</span>(<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// error...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，此时纹理的内容尚未定义。</p>
<p>要更新现有纹理的像素，必须使用update函数。它对许多类型的数据源具有重载。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从像素数组更新纹理</span></span><br><span class="line">sf::Uint8* pixels = <span class="keyword">new</span> sf::Uint8[width * height * <span class="number">4</span>]; <span class="comment">// * 4 因为像素有 4 个分量 (RGBA)</span></span><br><span class="line">...</span><br><span class="line">texture.<span class="built_in">update</span>(pixels);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sf::Image 更新纹理</span></span><br><span class="line">sf::Image image;</span><br><span class="line">...</span><br><span class="line">texture.<span class="built_in">update</span>(image);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从窗口的当前内容更新纹理</span></span><br><span class="line">sf::RenderWindow window;</span><br><span class="line">...</span><br><span class="line">texture.<span class="built_in">update</span>(window);</span><br></pre></td></tr></table></figure>

<p>这些示例都假定源与纹理具有相同的大小。如果不是这种情况，即如果您只想更新纹理的一部分，则可以指定要更新的子矩形的坐标。有关更多详细信息，请参阅文档。</p>
<p>此外，纹理具有两个属性，用于更改其渲染方式。</p>
<p>第一个属性允许平滑纹理。平滑纹理会使像素边界不那么明显（但图像会更加模糊）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">texture.<span class="built_in">setSmooth</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/12/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Sprites-and-textures/graphics-sprites-smooth.png" alt="graphics-sprites-smooth"></p>
<p>第二个属性允许在单个精灵中重复平铺纹理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">texture.<span class="built_in">setRepeated</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/12/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Sprites-and-textures/graphics-sprites-repeated.png" alt="graphics-sprites-repeated"></p>
<h1 id="现在可以拥有我的sprite了吗？"><a href="#现在可以拥有我的sprite了吗？" class="headerlink" title="现在可以拥有我的sprite了吗？"></a>现在可以拥有我的sprite了吗？</h1><p>创建子画面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sf::Sprite sprite;</span><br><span class="line">sprite.<span class="built_in">setTexture</span>(texture);</span><br></pre></td></tr></table></figure>

<p>最后画出来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主循环内，在 window.clear() 和 window.display() 之间</span></span><br><span class="line">window.<span class="built_in">draw</span>(sprite);</span><br></pre></td></tr></table></figure>

<p>如果不希望 Sprite 使用整个纹理，可以设置其纹理矩形。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sprite.<span class="built_in">setTextureRect</span>(sf::<span class="built_in">IntRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">32</span>, <span class="number">32</span>));</span><br></pre></td></tr></table></figure>

<p>你也可以改变<code>Sprite</code>的颜色。设置的颜色将随精灵的纹理进行调制（相乘）。这也可以用于更改精灵的全局透明度<code>（alpha）</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sprite.<span class="built_in">setColor</span>(sf::<span class="built_in">Color</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)); <span class="comment">// 绿色</span></span><br><span class="line">sprite.<span class="built_in">setColor</span>(sf::<span class="built_in">Color</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">128</span>)); <span class="comment">// 半透明</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/12/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Sprites-and-textures/graphics-sprites-color.png" alt="graphics-sprites-color"></p>
<p>精灵也可以变换：它们有位置，方向和比例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置</span></span><br><span class="line">sprite.<span class="built_in">setPosition</span>(sf::<span class="built_in">Vector2f</span>(<span class="number">10.f</span>, <span class="number">50.f</span>)); <span class="comment">// 绝对位置</span></span><br><span class="line">sprite.<span class="built_in">move</span>(sf::<span class="built_in">Vector2f</span>(<span class="number">5.f</span>, <span class="number">10.f</span>)); <span class="comment">// 相对于当前位置的偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回转</span></span><br><span class="line">sprite.<span class="built_in">setRotation</span>(<span class="number">90.f</span>); <span class="comment">// 绝对角度</span></span><br><span class="line">sprite.<span class="built_in">rotate</span>(<span class="number">15.f</span>); <span class="comment">// 相对于当前角度的偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规模</span></span><br><span class="line">sprite.<span class="built_in">setScale</span>(sf::<span class="built_in">Vector2f</span>(<span class="number">0.5f</span>, <span class="number">2.f</span>)); <span class="comment">// 绝对比例因子</span></span><br><span class="line">sprite.<span class="built_in">scale</span>(sf::<span class="built_in">Vector2f</span>(<span class="number">1.5f</span>, <span class="number">3.f</span>)); <span class="comment">// 相对于当前比例的因子</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，这三个转换的原点位于子画面的左上角。如果要将原点设置为其他点（例如，子画面的中心或其他角），则可以使用<code>setOrigin</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sprite.<span class="built_in">setOrigin</span>(sf::<span class="built_in">Vector2f</span>(<span class="number">25.f</span>, <span class="number">25.f</span>));</span><br></pre></td></tr></table></figure>

<p>由于转换函数对于所有<code>SFML</code>实体都是通用的，因此在单独的教程：<code>Transforming entities.</code>中对其进行了解释。</p>
<h1 id="白色方块问题"><a href="#白色方块问题" class="headerlink" title="白色方块问题"></a>白色方块问题</h1><p>您已成功加载纹理，正确构造了子画面，并且…您现在在屏幕上看到的只是一个白色正方形。发生了什么事？</p>
<p>这是一个常见的错误。设置子画面的纹理时，它在内部所做的就是存储指向纹理实例的指针。因此，如果纹理被破坏或移动到内存中的其他位置，则子画面最终会得到一个无效的纹理指针。</p>
<p>当您编写此类函数时，会出现此问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sf::Sprite <span class="title">loadSprite</span><span class="params">(std::string filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sf::Texture texture;</span><br><span class="line">    texture.<span class="built_in">loadFromFile</span>(filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sf::<span class="built_in">Sprite</span>(texture);</span><br><span class="line">&#125; <span class="comment">// 错误：纹理在这里被破坏</span></span><br></pre></td></tr></table></figure>

<p>你必须正确管理纹理的生存期，并确保只要任何子画面使用它们，它们就会存在。</p>
<h1 id="使用尽可能少的纹理"><a href="#使用尽可能少的纹理" class="headerlink" title="使用尽可能少的纹理"></a>使用尽可能少的纹理</h1><p>使用尽可能少的纹理是一个很好的策略，原因很简单：更改当前纹理对于图形卡来说是一项昂贵的操作。绘制许多使用相同纹理的精灵将产生最佳性能。</p>
<p>此外，使用单个纹理可以将静态几何体分组到单个实体中（每次调用只能使用一个纹理），这比一组多个实体的绘制速度快得多。批处理静态几何涉及其他类，因此超出了本教程的范围，有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php">vertex array</a>教程。</p>
<p>在创建动画工作表或切片集时，请牢记这一点：使用尽可能少的纹理。</p>
<h1 id="用OpenGL使用sf-Texture"><a href="#用OpenGL使用sf-Texture" class="headerlink" title="用OpenGL使用sf::Texture"></a>用OpenGL使用sf::Texture</h1><p>如果您使用的是 OpenGL 而不是 SFML 的图形实体，您仍然可以使用 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Texture.php"><code>sf::Texture</code></a> 作为 OpenGL 纹理对象的包装器，并将其与 OpenGL 代码的其余部分一起使用。</p>
<p>要绑定 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Texture.php"><code>sf::Texture</code></a> 进行绘制（基本上是<code>glBindTexture</code>），请调用静态函数：<code>bind</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sf::Texture texture;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定纹理</span></span><br><span class="line">sf::Texture::<span class="built_in">bind</span>(&amp;texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此处绘制纹理 OpenGL 实体...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定无纹理</span></span><br><span class="line">sf::Texture::<span class="built_in">bind</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/12/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Drawing-2D-stuff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="一只小帆帆">
      <meta itemprop="description" content="简介不了，慢慢观察">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帆帆的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/12/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Drawing-2D-stuff/" class="post-title-link" itemprop="url">预备知识(Drawing 2D stuff)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-12 09:44:09 / 修改时间：10:04:20" itemprop="dateCreated datePublished" datetime="2022-07-12T09:44:09+08:00">2022-07-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">C++制作小游戏</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">准备工作</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>官方文档：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-draw.php">Drawing 2D stuff (SFML &#x2F; Learn &#x2F; 2.5 Tutorials) (sfml-dev.org)</a></p>
<p>SFML提供了一个图形模块，它将帮助您以比OpenGL更简单的方式绘制2D实体。</p>
<h1 id="绘制窗口"><a href="#绘制窗口" class="headerlink" title="绘制窗口"></a>绘制窗口</h1><p>若要绘制图形模块提供的图元，必须使用专用窗口类：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderWindow.php"><code>sf::RenderWindow</code></a>。此类派生自 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Window.php"><code>sf::Window</code></a>，并继承其所有函数。您学到的有关 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Window.php"><code>sf::Window</code></a> 的所有内容（创建、事件处理、控制帧速率、与 OpenGL 混合等）也适用于 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderWindow.php"><code>sf::RenderWindow</code></a>。</p>
<p>除此之外，<code>sf::RenderWindow</code>还添加了高级函数来帮助您轻松绘制。在本教程中，我们将重点介绍其中两个函数：<code>clear</code> and <code>draw</code>。它们就像其名称所暗示的那样简单：clear用所选颜色清除整个窗口，并用draw绘制您传递给它的任何对象。</p>
<p>以下是渲染窗口中典型的主循环的外观：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SFML/Graphics.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    <span class="function">sf::RenderWindow <span class="title">window</span><span class="params">(sf::VideoMode(<span class="number">800</span>, <span class="number">600</span>), <span class="string">&quot;My window&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要窗口打开就运行程序</span></span><br><span class="line">    <span class="keyword">while</span> (window.<span class="built_in">isOpen</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检查自上次循环迭代以来触发的所有窗口事件</span></span><br><span class="line">        sf::Event event;</span><br><span class="line">        <span class="keyword">while</span> (window.<span class="built_in">pollEvent</span>(event))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &quot;close requested&quot; event: 关闭窗口</span></span><br><span class="line">            <span class="keyword">if</span> (event.type == sf::Event::Closed)</span><br><span class="line">                window.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用黑色清除窗口</span></span><br><span class="line">        window.<span class="built_in">clear</span>(sf::Color::Black);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// draw everything here...</span></span><br><span class="line">        <span class="comment">// window.draw(...);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束当前帧</span></span><br><span class="line">        window.<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须在绘制任何内容之前<code>clear</code>，否则之前帧中的内容将显示在您绘制的任何内容后面。唯一的例外是，当您用绘制的内容覆盖整个窗口时，没有像素不会被绘制到。在这种情况下，您可以避免调用<code>clear</code>（尽管它不会对性能产生明显影响）。</p>
<p>调用显示也是必需的，它将自上次调用以来绘制的内容显示并显示在窗口上。事实上，事物不是直接绘制到窗口，而是绘制到隐藏的缓冲区。当您调用display时，这个缓冲区会被复制到窗口中，这称为双缓冲。</p>
<h1 id="现在可以画什么？"><a href="#现在可以画什么？" class="headerlink" title="现在可以画什么？"></a>现在可以画什么？</h1><p>SFML 提供了四种可绘制实体：其中三种已准备就绪（<em>子画面</em>、<em>文本</em>和<em>形状</em>），最后一种是构建基块，可帮助您创建自己的可绘制实体（<em>顶点数组</em>）。</p>
<p>尽管它们具有一些共同的属性，但这些实体中的每一个都有自己的细微差别，因此在专门的教程中进行了解释：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-sprite.php">Sprite tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-text.php">Text tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-shape.php">Shape tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/graphics-vertex-array.php">Vertex array tutorial</a></li>
</ul>
<h1 id="屏幕外绘图"><a href="#屏幕外绘图" class="headerlink" title="屏幕外绘图"></a>屏幕外绘图</h1><p>SFML 还提供了一种绘制到纹理而不是直接绘制到窗口的方法。为此，请使用 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTexture.php"><code>sf::RenderTexture</code></a> 而不是 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderWindow.php"><code>sf::RenderWindow</code></a>。它具有相同的绘图功能，继承自其公共基础：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTarget.php"><code>sf::RenderTarget</code></a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 500x500 的渲染纹理</span></span><br><span class="line">sf::RenderTexture renderTexture;</span><br><span class="line"><span class="keyword">if</span> (!renderTexture.<span class="built_in">create</span>(<span class="number">500</span>, <span class="number">500</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘图使用相同的功能</span></span><br><span class="line">renderTexture.<span class="built_in">clear</span>();</span><br><span class="line">renderTexture.<span class="built_in">draw</span>(sprite); <span class="comment">// 或任何其他可绘制的</span></span><br><span class="line">renderTexture.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取目标纹理（已经绘制了东西的地方）</span></span><br><span class="line"><span class="type">const</span> sf::Texture&amp; texture = renderTexture.<span class="built_in">getTexture</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其绘制到窗口</span></span><br><span class="line"><span class="function">sf::Sprite <span class="title">sprite</span><span class="params">(texture)</span></span>;</span><br><span class="line">window.<span class="built_in">draw</span>(sprite);</span><br></pre></td></tr></table></figure>

<p><code>getTexture</code>函数返回只读纹理，这意味着您只能使用它，而不能修改它。如果您需要在使用它之前对其进行修改，则可以将其复制到您自己的 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Texture.php"><code>sf::Texture</code></a> 实例并进行修改。&#96;&#96;</p>
<p><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTexture.php"><code>sf::RenderTexture</code></a> 还具有与 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderWindow.php"><code>sf::RenderWindow</code></a> 相同的函数，用于处理视图和 OpenGL。如果使用 OpenGL 绘制到渲染纹理，则可以使用<code>create</code>函数的第三个可选参数请求创建深度缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderTexture.<span class="built_in">create</span>(<span class="number">500</span>, <span class="number">500</span>, <span class="literal">true</span>); <span class="comment">// 启用深度缓冲区</span></span><br></pre></td></tr></table></figure>

<h1 id="从线程绘制"><a href="#从线程绘制" class="headerlink" title="从线程绘制"></a>从线程绘制</h1><p>SFML支持多线程绘图，您甚至不需要做任何事情就可以使其工作。唯一要记住的是在另一个线程中使用窗口之前先停用它。这是因为一个窗口（更准确地说是它的OpenGL上下文）不能同时在多个线程中处于活动状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">renderingThread</span><span class="params">(sf::RenderWindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 激活窗口的环境</span></span><br><span class="line">    window-&gt;<span class="built_in">setActive</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (window-&gt;<span class="built_in">isOpen</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 绘制...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束当前帧</span></span><br><span class="line">        window-&gt;<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建窗口（记住：由于操作系统限制，在主线程中创建它更安全）</span></span><br><span class="line">    <span class="function">sf::RenderWindow <span class="title">window</span><span class="params">(sf::VideoMode(<span class="number">800</span>, <span class="number">600</span>), <span class="string">&quot;OpenGL&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停用其 OpenGL 环境</span></span><br><span class="line">    window.<span class="built_in">setActive</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动渲染线程</span></span><br><span class="line">    <span class="function">sf::Thread <span class="title">thread</span><span class="params">(&amp;renderingThread, &amp;window)</span></span>;</span><br><span class="line">    thread.<span class="built_in">launch</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件/逻辑/任何循环</span></span><br><span class="line">    <span class="keyword">while</span> (window.<span class="built_in">isOpen</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/11/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-User-data-streams/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="一只小帆帆">
      <meta itemprop="description" content="简介不了，慢慢观察">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帆帆的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/11/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-User-data-streams/" class="post-title-link" itemprop="url">预备知识(User data streams)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-11 17:32:10 / 修改时间：17:41:53" itemprop="dateCreated datePublished" datetime="2022-07-11T17:32:10+08:00">2022-07-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">C++制作小游戏</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">准备工作</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>官方文档：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/system-stream.php">User data streams (SFML &#x2F; Learn &#x2F; 2.5 Tutorials) (sfml-dev.org)</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>SFML有几个资源类：图像，字体，声音等。在大多数程序中，这些资源将借助其功能从文件加载。在其他一些情况下，资源将直接打包到可执行文件或大数据文件中，并使用 从内存中加载。这些函数<em>几乎</em>涵盖了所有可能的用例，但不是全部。</p>
<p>有时，您希望从不寻常的位置加载文件，例如压缩&#x2F;加密的存档或远程网络位置。对于这些特殊情况，SFML 提供了第三个加载函数：。此函数使用抽象的 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1InputStream.php"><code>sf::InputStream</code></a> 接口读取数据，该接口允许您提供自己的与 SFML 配合使用的流类的实现。</p>
<h1 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h1><p><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1InputStream.php"><code>sf::InputStream</code></a> 类声明了四个虚函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InputStream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">InputStream</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Int64 <span class="title">read</span><span class="params">(<span class="type">void</span>* data, Int64 size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Int64 <span class="title">seek</span><span class="params">(Int64 position)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Int64 <span class="title">tell</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Int64 <span class="title">getSize</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>read</strong> 必须从流中提取<em>数据的大小</em>字节，并将它们复制到提供<em>的数据</em>地址。它返回读取的字节数，或在出错时返回 -1。</p>
<p><strong>Seek</strong>必须更改流中的当前读取位置。其<em>位置</em>参数是要跳转到的绝对字节偏移量（因此它是相对于数据的开头，而不是相对于当前位置）。它返回新位置，或在出错时返回 -1。</p>
<p><strong>tell</strong> 必须返回流中的当前读取位置（以字节为单位），如果出错时必须返回 -1。</p>
<p><strong>getSize</strong> 必须返回流中包含的数据的总大小（以字节为单位），如果出错时必须返回 -1。</p>
<p>要创建自己的工作流，你必须根据这四个函数的要求实现它们中的每一个。</p>
<h1 id="使用输出流"><a href="#使用输出流" class="headerlink" title="使用输出流"></a>使用输出流</h1><p>使用自定义流类非常简单：实例化它，并将其传递给要加载的对象的（或）函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sf::FileStream stream;</span><br><span class="line">stream.<span class="built_in">open</span>(<span class="string">&quot;image.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">sf::Texture texture;</span><br><span class="line">texture.<span class="built_in">loadFromStream</span>(stream);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/11/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Threads/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="一只小帆帆">
      <meta itemprop="description" content="简介不了，慢慢观察">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帆帆的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/11/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Threads/" class="post-title-link" itemprop="url">预备知识(Threads)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-11 16:33:03 / 修改时间：17:32:37" itemprop="dateCreated datePublished" datetime="2022-07-11T16:33:03+08:00">2022-07-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">C++制作小游戏</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">准备工作</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>官方文档：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/system-thread.php">Threads (SFML &#x2F; Learn &#x2F; 2.5 Tutorials) (sfml-dev.org)</a></p>
<h1 id="线程是什么？"><a href="#线程是什么？" class="headerlink" title="线程是什么？"></a>线程是什么？</h1><p>线程基本上是与其他线程并行运行的一系列指令。每个程序都由至少一个线程组成：主线程运行你的函数。仅使用主线程的程序是单线程的，如果添加一个或多个线程，它们将变为多线程。</p>
<p>简而言之，线程是一种同时执行多项操作的方法。例如，这对于在加载图像或声音时显示动画和对用户输入做出反应非常有用。线程也广泛用于网络编程，等待数据接收，同时继续更新和绘制应用程序。</p>
<h1 id="使用SFML创建线程"><a href="#使用SFML创建线程" class="headerlink" title="使用SFML创建线程"></a>使用SFML创建线程</h1><p>可以在 SFML 中创建线程的类是 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf::Thread</code></a>，下面是它在操作中的样子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SFML/System.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此函数在调用 thread.launch()时启动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m thread number one&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个以 func()作为入口点的线程</span></span><br><span class="line">    <span class="function">sf::Thread <span class="title">thread</span><span class="params">(&amp;func)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行它</span></span><br><span class="line">    thread.<span class="built_in">launch</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程继续运行...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m the main thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此代码中，两者都在调用后并行运行。结果是，来自这两个函数的文本应该在控制台中混合。</p>
<p>线程启动时将运行的函数必须传递给 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf::Thread</code></a> 的构造函数。<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf::Thread</code></a>试图灵活并接受各种各样的入口点：非成员或成员函数，有或没有参数，仿函数（Functor）等。上面的示例显示了如何使用非成员函数，下面是一些其他示例。</p>
<p>- 具有一个参数的非成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sf::Thread <span class="title">thread</span><span class="params">(&amp;func, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>-成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass object;</span><br><span class="line"><span class="function">sf::Thread <span class="title">thread</span><span class="params">(&amp;MyClass::func, &amp;object)</span></span>;</span><br></pre></td></tr></table></figure>

<p>-仿函数（函数对象）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyFunctor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">sf::Thread <span class="title">thread</span><span class="params">(MyFunctor())</span></span>;</span><br></pre></td></tr></table></figure>

<p>最后一个使用函子的示例是最强大的示例，因为它可以接受任何类型的函子，因此使 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf::Thread</code></a> 与许多不直接支持的函数类型兼容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// with lambdas</span></span><br><span class="line"><span class="function">sf::Thread <span class="title">thread</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;I am in thread!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// with std::bind</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::string, <span class="type">int</span>, <span class="type">double</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sf::Thread <span class="title">thread</span><span class="params">(std::bind(&amp;func, <span class="string">&quot;hello&quot;</span>, <span class="number">24</span>, <span class="number">0.5</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果要在类中使用 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf::Thread</code></a>，请不要忘记它没有默认构造函数。因此，您必须直接在构造函数的<em>初始化列表中对其进行初始化</em>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassWithThread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ClassWithThread</span>()</span><br><span class="line">    : <span class="built_in">m_thread</span>(&amp;ClassWithThread::f, <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sf::Thread m_thread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果确实需要在构造 owner 对象<em>后</em>构造 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf::Thread</code></a> 实例，还可以通过在堆上动态分配来延迟其构造。</p>
<h1 id="开始线程"><a href="#开始线程" class="headerlink" title="开始线程"></a>开始线程</h1><p>创建 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf::Thread</code></a> 实例后，必须使用函数<code>launch</code>启动它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sf::Thread <span class="title">thread</span><span class="params">(&amp;func)</span></span>;</span><br><span class="line">thread.<span class="built_in">launch</span>();</span><br></pre></td></tr></table></figure>

<p><code>launch</code>调用您在新线程中传递给构造函数的函数，并立即返回，以便调用线程可以继续运行。</p>
<h1 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h1><p>当线程的入口点函数返回时，线程会自动停止。如果要等待一个线程从另一个线程完成，可以调用wait函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sf::Thread <span class="title">thread</span><span class="params">(&amp;func)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始线程</span></span><br><span class="line">thread.<span class="built_in">launch</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞执行直到线程完成</span></span><br><span class="line">thread.<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>

<h1 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h1><p><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf：：Thread</code></a> 中没有允许另一个线程暂停它的函数，暂停线程的唯一方法是从它运行的代码中执行此操作。换句话说，您只能暂停当前线程。为此，您可以调用该函数：<code>sf::sleep</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sf::<span class="built_in">sleep</span>(sf::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sf::sleep</code>有一个参数，那就是睡觉的时间。此持续时间可以使用任何单位&#x2F;精度给出，如<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/tutorials/2.5/system-time.php">时间教程</a>中所示。<br>请注意，您可以使用此函数使任何线程进入睡眠状态，即使是主线程。</p>
<p><code>sf::sleep</code>是暂停线程的最有效方法：只要线程进入睡眠状态，就不需要 CPU。基于活动等待的暂停，如空循环，将消耗100%的CPU什么都不做。但是，请记住，睡眠持续时间只是一个提示，根据操作系统的不同，它将或多或少地准确。因此，不要依赖它来获得非常精确的时间。</p>
<h1 id="保护共享数据"><a href="#保护共享数据" class="headerlink" title="保护共享数据"></a>保护共享数据</h1><p>程序中的所有线程共享相同的内存，它们可以访问其所在范围内的所有变量。这非常方便，但也很危险：由于线程并行运行，这意味着可以同时从多个线程同时使用变量或函数。如果操作不是线程安全的，则可能导致未定义的行为（即，它可能会崩溃或损坏数据）。</p>
<p>有几种编程工具可帮助您保护共享数据并使代码线程安全，这些工具称为同步基元。常见的是互斥锁，信号量，条件变量和自旋锁。它们都是同一概念的变体：它们通过仅允许某些线程访问代码而阻止其他线程来保护代码段。</p>
<p>最基本（和使用的）基元是互斥体。Mutex代表“MUTual EXclusion”：它确保只有一个线程能够运行它所保护的代码。让我们看看他们如何为上面的示例带来一些秩序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SFML/System.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">sf::Mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m thread number one&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">sf::Thread <span class="title">thread</span><span class="params">(&amp;func)</span></span>;</span><br><span class="line">    thread.<span class="built_in">launch</span>();</span><br><span class="line"></span><br><span class="line">    mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m the main thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码使用共享资源 （），正如我们所看到的，它会产生不需要的结果 - 所有内容都在控制台中混合。为了确保正确打印完整的行而不是随机混合，我们使用互斥锁保护代码的相应区域。</p>
<p>到达其行的第一个线程成功锁定互斥体，直接访问其后面的代码并打印其文本。当另一个线程到达其行时，互斥体已被锁定，因此线程被置于休眠状态（例如，休眠线程不会消耗 CPU 时间）。当第一个线程最终解锁互斥体时，第二个线程将被唤醒，并允许锁定互斥体并打印其文本块。这会导致文本行按顺序显示在控制台中，而不是混合出现。</p>
<p>互斥体不是可用于保护共享变量的唯一基元，如果你的应用程序使用线程执行复杂的操作，寻找具有更多功能的真正线程库。</p>
<h1 id="保护互斥锁"><a href="#保护互斥锁" class="headerlink" title="保护互斥锁"></a>保护互斥锁</h1><p>为了确保互斥锁始终在可能引发异常的环境中解锁，SFML 提供了一个 RAII 类来包装它们：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Lock.php"><code>sf::Lock</code></a>。它在其构造函数中锁定互斥体，并在其析构函数中将其解锁。简单高效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sf::Mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">sf::Lock <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// mutex.lock()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">functionThatMightThrowAnException</span>(); <span class="comment">// mutex.unlock() 如果这个函数抛出</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// mutex.unlock()</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Lock.php"><code>sf::Lock</code></a> 在具有多个语句的函数中也很有用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sf::Mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">sf::Lock <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// mutex.lock()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!image1.<span class="built_in">loadFromFile</span>(<span class="string">&quot;...&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// mutex.unlock()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!image2.<span class="built_in">loadFromFile</span>(<span class="string">&quot;...&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// mutex.unlock()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!image3.<span class="built_in">loadFromFile</span>(<span class="string">&quot;...&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// mutex.unlock()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="comment">// mutex.unlock()</span></span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><p>程序员经常忽略的一件事是，如果没有相应的<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf：：Thread</code></a>实例，线程就无法生存。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">startThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">sf::Thread <span class="title">thread</span><span class="params">(&amp;funcToRunInThread)</span></span>;</span><br><span class="line">    thread.<span class="built_in">launch</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">startThread</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写此类代码的程序员希望函数启动一个线程，该线程将独立存在，并在线程化函数结束时被销毁。事实并非如此。线程化函数似乎阻塞了主线程，就好像线程不起作用一样。</p>
<p>这是什么原因造成的？<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf::Thread</code></a> 实例是函数的本地实例，因此当函数返回时，会立即销毁。调用 <a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Thread.php"><code>sf::Thread</code></a> 的析构函数，正如我们上面所了解的那样，调用它，结果是主线程阻塞并等待线程函数完成，而不是继续并行运行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/11/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Handling-time/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="一只小帆帆">
      <meta itemprop="description" content="简介不了，慢慢观察">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帆帆的BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/11/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-Handling-time/" class="post-title-link" itemprop="url">预备知识(Handling time)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-11 08:32:20" itemprop="dateCreated datePublished" datetime="2022-07-11T08:32:20+08:00">2022-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-22 19:37:04" itemprop="dateModified" datetime="2022-07-22T19:37:04+08:00">2022-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index"><span itemprop="name">C++制作小游戏</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%88%B6%E4%BD%9C%E5%B0%8F%E6%B8%B8%E6%88%8F/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">准备工作</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SFML中的时间"><a href="#SFML中的时间" class="headerlink" title="SFML中的时间"></a>SFML中的时间</h1><p>与许多其他时间是 uint32 毫秒数或浮点数秒数的库不同，SFML 不会对时间值施加任何特定的单位或类型。相反，它通过一个灵活的类将这个选择留给用户：<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Time.php"><code>sf::Time</code></a>。所有操作时间值的 SFML 类和函数都使用此类。</p>
<p>sf::Time 表示一个时间段（换句话说，两个事件之间经过的时间）。它不是一个日期时间类，它将当前年&#x2F;月&#x2F;日&#x2F;小时&#x2F;分钟&#x2F;秒表示为时间戳，它只是一个表示一定时间量的值，如何解释它取决于使用它的上下文。</p>
<h1 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h1><p><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Time.php"><code>sf::Time</code></a> 值可以从不同的源单位构造：秒、毫秒和微秒。有一个（非成员）函数可以将它们中的每一个转换为<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Time.php"><code>sf::Time</code></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sf::Time t1 = sf::<span class="built_in">microseconds</span>(<span class="number">10000</span>);</span><br><span class="line">sf::Time t2 = sf::<span class="built_in">milliseconds</span>(<span class="number">10</span>);</span><br><span class="line">sf::Time t3 = sf::<span class="built_in">seconds</span>(<span class="number">0.01f</span>);</span><br></pre></td></tr></table></figure>

<p>请注意，这三个时间都是相等的。</p>
<p>同样，<a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Time.php"><code>sf::Time</code></a> 可以转换回秒、毫秒或微秒：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sf::Time time = ...;</span><br><span class="line"></span><br><span class="line">sf::Int64 usec = time.<span class="built_in">asMicroseconds</span>();</span><br><span class="line">sf::Int32 msec = time.<span class="built_in">asMilliseconds</span>();</span><br><span class="line"><span class="type">float</span>     sec  = time.<span class="built_in">asSeconds</span>();</span><br></pre></td></tr></table></figure>

<h1 id="使用时间值"><a href="#使用时间值" class="headerlink" title="使用时间值"></a>使用时间值</h1><p><a target="_blank" rel="noopener" href="https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Time.php"><code>sf::时间</code></a>只是一个时间量，所以它支持算术运算，如加法，减法，比较等。时间也可能是负数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sf::Time t1 = ...;</span><br><span class="line">sf::Time t2 = t1 * <span class="number">2</span>;</span><br><span class="line">sf::Time t3 = t1 + t2;</span><br><span class="line">sf::Time t4 = -t3;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b1 = (t1 == t2);</span><br><span class="line"><span class="type">bool</span> b2 = (t3 &gt; t4);</span><br></pre></td></tr></table></figure>

<h1 id="测量时间"><a href="#测量时间" class="headerlink" title="测量时间"></a>测量时间</h1><p>SFML有一个非常简单的时间来测量时间的类：sf::Clock。它只有两个函数：<code>getElapsed</code>、<code>restart</code>检索自时钟启动以来经过的时间，以及重新启动时钟。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sf::Clock clock; <span class="comment">// 启动时钟</span></span><br><span class="line">...</span><br><span class="line">sf::Time elapsed1 = clock.<span class="built_in">getElapsedTime</span>();</span><br><span class="line">std::cout &lt;&lt; elapsed1.<span class="built_in">asSeconds</span>() &lt;&lt; std::endl;</span><br><span class="line">clock.<span class="built_in">restart</span>();</span><br><span class="line">...</span><br><span class="line">sf::Time elapsed2 = clock.<span class="built_in">getElapsedTime</span>();</span><br><span class="line">std::cout &lt;&lt; elapsed2.<span class="built_in">asSeconds</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>下面是一个示例，它使用游戏循环的每次迭代所经过的时间来更新游戏逻辑</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sf::Clock clock;</span><br><span class="line"><span class="keyword">while</span> (window.<span class="built_in">isOpen</span>())</span><br><span class="line">&#123;</span><br><span class="line">    sf::Time elapsed = clock.<span class="built_in">restart</span>();</span><br><span class="line">    <span class="built_in">updateGame</span>(elapsed);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="一只小帆帆"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">一只小帆帆</p>
  <div class="site-description" itemprop="description">简介不了，慢慢观察</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">一只小帆帆</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <script type="text/javascript" src="//libs.baidu.com/jquery/1.8.3/jquery.min.js"></script>
  <!-- 雪花特效 -->
  <script type="text/javascript">
    var windowWidth = $(window).width();
    if (windowWidth > 480) {
      document.write('<script type="text/javascript" src="/js/src/snow.js"><\/script>');
    }
  </script>
</body>
</html>
